Object subclass: #Regex	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Regex methodsFor: 'as yet unclassified' stamp: 'JuanGonzalez 6/17/2018 14:13'!star	^Star new with: self.! !!Regex methodsFor: 'logical operations' stamp: 'JuanGonzalez 6/17/2018 14:16'!| expr	^ Or new with: self and: expr. ! !!Regex methodsFor: 'copying' stamp: 'JuanGonzalez 6/17/2018 14:16'!, expr	^ Concat  new with: self and: expr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Regex class	instanceVariableNames: ''!!Regex class methodsFor: 'requirements' stamp: 'JuanGonzalez 6/17/2018 14:06'!empty	^Empty new.! !!Regex class methodsFor: 'reflective operations' stamp: 'JuanGonzalez 6/25/2018 19:55'!doesNotUnderstand: aMessage	| messageAsString |	messageAsString := (aMessage asString).	^((messageAsString size = 1) ifTrue: [RegexSymbol new with: (messageAsString first) ] ifFalse: [ super doesNotUnderstand: (messageAsString first) ]).! !Regex subclass: #Concat	instanceVariableNames: 'anExpr anotherExpr'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Concat methodsFor: 'comparing' stamp: 'JuanGonzalez 6/25/2018 23:08'!match: anString	|separator left right matchs partition_matches|	matchs := false.	separator := Separator new with: anString.	[ separator right isNotEmpty ] whileTrue: [		left := separator left.		right := separator right.		partition_matches:= (anExpr match: left) & (anotherExpr match: right).		matchs := matchs | partition_matches.		separator next.	].	^matchs.	! !!Concat methodsFor: 'accessing' stamp: 'JuanGonzalez 6/17/2018 14:20'!prefix	^anExpr.! !!Concat methodsFor: 'accessing' stamp: 'JuanGonzalez 6/17/2018 14:26'!suffix	^anotherExpr.! !!Concat methodsFor: 'as yet unclassified' stamp: 'JuanGonzalez 6/17/2018 13:52'!with: expr1 and: expr2	anExpr := expr1.	anotherExpr := expr2.! !!Concat methodsFor: 'testing' stamp: 'JuanGonzalez 6/17/2018 14:01'!hasStar	^anExpr hasStar or: anotherExpr hasStar.! !!Concat methodsFor: 'printing' stamp: 'JuanGonzalez 6/17/2018 13:56'!printString	^ anExpr printString, anotherExpr printString.! !!Concat methodsFor: 'logical operations' stamp: 'JuanGonzalez 6/17/2018 14:14'!| expr	^ Or new with: self and: expr. ! !!Concat methodsFor: 'initialization' stamp: 'JuanGonzalez 6/17/2018 18:32'!length: aBlockClosure	^(anExpr length: aBlockClosure ) +(anotherExpr length: aBlockClosure).! !Regex subclass: #Empty	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Empty methodsFor: 'testing' stamp: 'JuanGonzalez 6/17/2018 14:00'!hasStar	^false.! !!Empty methodsFor: 'comparing' stamp: 'JuanGonzalez 6/17/2018 18:44'!match: anString	^anString = ''.! !!Empty methodsFor: 'initialization' stamp: 'JuanGonzalez 6/17/2018 18:35'!length: aBlockClosure	^0.! !!Empty methodsFor: 'printing' stamp: 'JuanGonzalez 6/17/2018 13:56'!printString	^'empty'! !Regex subclass: #Or	instanceVariableNames: 'option1 option2'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Or methodsFor: 'accessing' stamp: 'JuanGonzalez 6/17/2018 14:20'!option2	^option2.! !!Or methodsFor: 'accessing' stamp: 'JuanGonzalez 6/17/2018 14:19'!option1	^option1.! !!Or methodsFor: 'as yet unclassified' stamp: 'JuanGonzalez 6/17/2018 14:19'!with: expr1 and: expr2	option1 := expr1.	option2 := expr2.! !!Or methodsFor: 'testing' stamp: 'JuanGonzalez 6/17/2018 14:19'!hasStar	^option1 hasStar or: option2 hasStar.! !!Or methodsFor: 'initialization' stamp: 'JuanGonzalez 6/17/2018 17:34'!length: aBlockClosure	^aBlockClosure value: (option1 length: aBlockClosure ) value: (option2 length: aBlockClosure).! !!Or methodsFor: 'printing' stamp: 'JuanGonzalez 6/17/2018 15:58'!printString	^ '(',option1 printString, '|', option2 printString, ')'.! !!Or methodsFor: 'comparing' stamp: 'JuanGonzalez 6/17/2018 18:46'!match: anString	^ (option1 match: anString) or: (option2 match: anString ).! !Regex subclass: #RegexSymbol	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!RegexSymbol methodsFor: 'testing' stamp: 'JuanGonzalez 6/17/2018 14:00'!hasStar	^false.! !!RegexSymbol methodsFor: 'printing' stamp: 'JuanGonzalez 6/17/2018 15:56'!printString	^value asString.! !!RegexSymbol methodsFor: 'instance creation' stamp: 'JuanGonzalez 6/17/2018 13:53'!with: val	value := val.! !!RegexSymbol methodsFor: 'initialization' stamp: 'JuanGonzalez 6/17/2018 18:19'!length: aBlockClosure	^1.! !!RegexSymbol methodsFor: 'comparing' stamp: 'JuanGonzalez 6/17/2018 18:45'!match: anString	^self printString = anString.! !!RegexSymbol methodsFor: 'accessing' stamp: 'JuanGonzalez 6/25/2018 19:52'!value	^value.! !Object subclass: #Separator	instanceVariableNames: 'left right aBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Separator methodsFor: 'accessing' stamp: 'JuanGonzalez 6/25/2018 21:44'!right	^right.! !!Separator methodsFor: 'accessing' stamp: 'JuanGonzalez 6/25/2018 21:54'!next	aBlock value.! !!Separator methodsFor: 'accessing' stamp: 'JuanGonzalez 6/25/2018 21:44'!left	^left.! !!Separator methodsFor: 'instance creation' stamp: 'JuanGonzalez 6/25/2018 21:48'!with: anString	left:= ''.	right:= anString.	aBlock := [left := left, (right first asString). right:= right allButFirst].! !Regex subclass: #Star	instanceVariableNames: 'expr'	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!Star methodsFor: 'initialization' stamp: 'JuanGonzalez 6/17/2018 17:55'!length: aBlockClosure	^aBlockClosure value: (Float infinity) value: 0.! !!Star methodsFor: 'testing' stamp: 'JuanGonzalez 6/17/2018 13:59'!hasStar	^true.! !!Star methodsFor: 'comparing' stamp: 'JuanGonzalez 6/25/2018 22:51'!match: anString(anString = '') ifTrue:[^true] ifFalse:[	|separator left right matchs left_side_matches|	matchs := false.	separator := Separator new with: anString.	[ separator right isNotEmpty ] whileTrue: [		separator next.		left := separator left.		right := separator right.		left_side_matches:= (expr match: left).		matchs := matchs | (left_side_matches & (self match: right)) .	].	^matchs.].	! !!Star methodsFor: 'instance creation' stamp: 'JuanGonzalez 6/17/2018 13:55'!with: exp	expr := exp.! !!Star methodsFor: 'evaluating' stamp: 'JuanGonzalez 6/17/2018 14:26'!value	^expr.! !!Star methodsFor: 'printing' stamp: 'JuanGonzalez 6/17/2018 13:58'!printString	^'(',expr printString ,')*'.! !TestCase subclass: #TestEj1	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj1 methodsFor: 'tests' stamp: 'JuanGonzalez 6/25/2018 19:54'!test1_1_regex	|e a b c d aaa a_b ab|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	d := Regex d.	aaa := a star.	a_b := a | b.	ab := a , b.		self assert: e isNotNil.	self assert: a isNotNil.	self assert: b isNotNil.	self assert: a_b isNotNil.	self assert: aaa isNotNil.	self assert: ab isNotNil.	self assert: a value equals: $a.	self assert: b value equals: $b.	self assert: aaa value equals: a.	self assert: a_b option1 equals: a.	self assert: a_b option2 equals: b.	self assert: ab prefix equals: a.	self assert: ab suffix equals: b.! !TestCase subclass: #TestEj2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj2 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/6/2018 03:48'!test2_1_hasStar	|e a b c aaa b_c aaab_c|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.		self assert: aaa hasStar.	self assert: aaab_c hasStar.	self assert: e hasStar not.	self assert: a hasStar not.	self assert: b_c hasStar not.! !!TestEj2 methodsFor: 'tests' stamp: 'JuanGonzalez 6/17/2018 15:58'!test2_2_printString	|e a b c aaa abc b_c aaab_c|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	abc := a , b , c.	b_c := b | c.	aaab_c := aaa , b_c.		self assert: e printString equals: 'empty'.	self assert: a printString equals: 'a'.	self assert: abc printString equals: 'abc'.	self assert: b_c printString equals: '(b|c)'.	self assert: aaa printString equals: '(a)*'.	self assert: aaab_c printString equals: '(a)*(b|c)'.! !TestCase subclass: #TestEj3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj3 methodsFor: 'tests' stamp: 'JuanGonzalez 6/17/2018 18:33'!test3_1_minLength	|e a b c aaa b_c aaab_c min|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	min := [:x :y | x min: y].		self assert: (aaa length: min) equals: 0.	self assert: (aaab_c length: min) equals: 1.	self assert: (e length: min) equals: 0.	self assert: (a length: min) equals: 1.	self assert: (b_c length: min) equals: 1.! !!TestEj3 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:09'!test3_2_maxLength	|e a b c aaa b_c aaab_c max|		e := Regex empty.	a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	max := [:x :y | x max: y].		self assert: (aaa length: max) isInfinite.	self assert: (aaab_c length: max) isInfinite.	self assert: (e length: max) equals: 0.	self assert: (a length: max) equals: 1.	self assert: (b_c length: max) equals: 1.! !TestCase subclass: #TestEj4	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PLP'!!TestEj4 methodsFor: 'tests' stamp: 'JuanGonzalez 6/17/2018 18:37'!test4_1_empty	|e|		e := Regex empty.		self assert: (e match: '').	"self assert: (e match: 'a') not."! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:06'!test4_2_char	|a b|		a := Regex a.	b := Regex b.		self assert: (a match: 'a').	self assert: (a match: '') not.	self assert: (a match: 'b') not.	self assert: (a match: 'ab') not.		self assert: (b match: 'b').	self assert: (b match: '') not.	self assert: (b match: 'a') not.	self assert: (b match: 'ba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:07'!test4_4_or	|a b a_b|		a := Regex a.	b := Regex b.	a_b := a | b.		self assert: (a_b match: 'a').	self assert: (a_b match: 'b').	self assert: (a_b match: '') not.	self assert: (a_b match: 'ab') not.	self assert: (a_b match: 'ba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'JuanGonzalez 6/25/2018 22:10'!test4_3_concat	|a b ab|		a := Regex a.	b := Regex b.	ab := a , b.		self assert: (ab match: 'ab').	self assert: (ab match: '') not.	self assert: (ab match: 'a') not.	self assert: (ab match: 'aba') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/11/2018 22:32'!test4_6_match	|a b c b_c aaa aaab_c bbbb|		a := Regex a.	b := Regex b.	c := Regex c.	aaa := a star.	b_c := b | c.	aaab_c := aaa , b_c.	bbbb := b star , b.		self assert: (aaab_c match: 'b').	self assert: (aaab_c match: 'c').	self assert: (aaab_c match: 'ab').	self assert: (aaab_c match: 'ac').	self assert: (aaab_c match: 'aab').	self assert: (aaab_c match: 'aaac').	self assert: (bbbb match: 'b').	self assert: (bbbb match: 'bb').	self assert: (bbbb match: 'bbb').	self assert: (bbbb match: '') not.	self assert: (aaab_c match: '') not.	self assert: (aaab_c match: 'a') not.	self assert: (aaab_c match: 'aa') not.	self assert: (aaab_c match: 'aaa') not.	self assert: (aaab_c match: 'ba') not.	self assert: (aaab_c match: 'ca') not.! !!TestEj4 methodsFor: 'tests' stamp: 'EdgardoZoppi 6/7/2018 00:08'!test4_5_star	|a aaa|		a := Regex a.	aaa := a star.		self assert: (aaa match: '').	self assert: (aaa match: 'a').	self assert: (aaa match: 'aa').	self assert: (aaa match: ('a' repeat: (Random new nextInt: 10))).	self assert: (aaa match: 'b') not.	self assert: (aaa match: 'ab') not.	self assert: (aaa match: 'aab') not.! !